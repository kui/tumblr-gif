#!/bin/bash
# ---------------------------------------------
# Artifact:     tumblr-gif/tumblr-gif
# Version:      1.1.0
# Date (UTC):   Sat, 16 Aug 2014 17:21:20 +0000
# Generated by: bashing 0.2.0
# ---------------------------------------------
export __BASHING_VERSION='0.2.0'
export __VERSION='1.1.0'
export __ARTIFACT_ID='tumblr-gif'
export __GROUP_ID='tumblr-gif'
set -eu
if [[ -z "${WORKSPACE-}" ]]; then
    WORKSPACE=/tmp/tumblr-gif
fi
if [[ -z "${RC_FILE-}" ]]; then
    RC_FILE="$HOME/.tumblr-gif-rc.sh"
fi
function is_debug_enable() {
    [[ -n "${DEBUG-}" ]]
}
function debug() {
    if is_debug_enable
    then echo "$@"
    fi
}
function set_x() {
    if is_debug_enable
    then set -x
    fi
}
function abort() {
    err "$@"
    exit $(status_code "$*")
}
function status_code() {
    local c=$(hash_code 255 "$*")
    echo $((c + 1))
}
function hash_code() {
    local base=$1
    shift
    local s=$(sum <<< "$*" | cut -d' ' -f1)
    bc <<< "$s % $base"
}
function err() {
    echo -e "$@" >&2
}
function is_int() {
    [[ "$1" =~ [0-9]+ ]]
}
function clean_files() {
    rm -vrf -- "$WORKSPACE"/*
}
MAX_FILE_SIZE=$((995 * 1000)) # 998 KB
MIN_FILE_SIZE=$((990 * 1000)) # 990 KB
MAX_SIDE=500
function do_convert() {
    if $is_half
    then update_for_half_limits
    fi
    if [[ $MIN_FILE_SIZE -gt $MAX_FILE_SIZE ]]; then
        abort "ERROR: invalid MIN/MAX_FILE_SIZE: ${MIN_FILE_SIZE}/${MAX_FILE_SIZE}"
    elif [[ $(list_frames | wc -l) -lt $frame_interval ]]; then
        abort "ERROR: too less images"
    fi
    printf '  %s images, %sB (avg: %sKB)\n' \
        $(list_frames | wc -l) \
        $(du -sh $WORKSPACE | cut -f1) \
        $(bc <<< "$(du -s $WORKSPACE | cut -f1) / $(ls $WORKSPACE/* | wc -l)")
    rm_blendeds
    if [[ $blend_loop -gt 0 ]]; then
        gen_blendeds
    fi
    if $is_echo_convert; then
        echo "$(convert_cmd $init_width)"
        return 0
    fi
    gen_gif $init_width
    if is_valid_gif; then
        echo "Success!"
        return 0
    fi
    local width_history=$(get_width)
    local sides w
    while true ; do
        w=$(next_width)
        if grep -qF $w <<< "$width_history"; then
            echo "GIF width convergence: ${w}x"
            echo "Success?"
            return 0
        elif [[ $w -lt $((MAX_SIDE / 2 )) ]]; then
            abort "ERROR: Too large or many frames to make a GIF\nabort"
            return 1
        else
            width_history="$width_history $w"
        fi
        gen_gif $w
        if is_valid_gif; then
            break
        fi
    done
    echo "Success"
}
function update_for_half_limits() {
    MAX_FILE_SIZE=$((1998 * 1000)) # 1998 KB
    MIN_FILE_SIZE=$((1990 * 1000)) # 1990 KB
    MAX_SIDE=245
}
function list_frames() {
    ls -- $WORKSPACE | grep -vP '^__blended-\d+\.png$'
}
function rm_blendeds() {
    ls -- $WORKSPACE | grep -P '^__blended-\d+\.png$' | xargs -I{} rm $WORKSPACE/{}
}
function is_valid_gif() {
    local size=$(get_size)
    local geo=$(get_geometry)
    local width=$(cut -f1 -dx <<< $geo)
    local height=$(cut -f2 -dx <<< $geo)
    ( is_valid_sides $width $height && is_expected_size_range $size) \
        || ( is_max_sides $width $height && is_valid_size $size)
}
function is_valid_sides() {
    local w=$1 h=$2
    if [[ $w -gt $h ]]
    then [[ $w -le $MAX_SIDE ]]
    else [[ $h -le $MAX_SIDE ]]
    fi
}
function is_expected_size_range() {
    [[ $1 -le $MAX_FILE_SIZE \
        && $1 -ge $MIN_FILE_SIZE ]]
}
function is_max_sides() {
    local w=$1 h=$2
    if [[ $w -gt $h ]]
    then [[ $w -eq $MAX_SIDE ]]
    else [[ $h -eq $MAX_SIDE ]]
    fi
}
function is_valid_size() {
    [[ $1 -le $MAX_FILE_SIZE ]]
}
function get_geometry() {
    identify -format '%[fx:w]x%[fx:h]\n' "$output_gif" | head -n 1
    return ${PIPESTATUS[0]}
}
function get_width() {
    identify -format '%[fx:w]\n' "$output_gif" | head -n 1
    return ${PIPESTATUS[0]}
}
function get_size() {
    stat -c%s "$output_gif"
}
function next_width() {
    local geo=$(get_geometry)
    local w=$(cut -f1 -dx <<< $geo)
    local h=$(cut -f2 -dx <<< $geo)
    local s=$(get_size)
    local next_w=$(evenize $(bc -l <<< "sqrt($MAX_FILE_SIZE / $s) * $w"))
    if [[ $next_w -gt $MAX_SIDE ]]; then
        next_w=$MAX_SIDE
    fi
    local next_h=$(((h * next_w) / w))
    if [[ $next_h -gt $MAX_SIDE ]]; then
        next_h=$MAX_SIDE
        next_w=$(((w * next_h) / h))
    fi
    echo ${next_w}
}
function evenize() {
    local i=${1%.*}
    echo $((i / 2 * 2))
}
function gen_blendeds() {
    local first_frame="$(get_first_frame)"
    local last_frame="$(get_last_frame)"
    local interval=$(( 100 / ( blend_loop + 1 ) ))
    local percent out
    for percent in $(seq $interval $interval $((100 - interval))); do
        out="$WORKSPACE/$(printf '__blended-%02d.png' $percent)"
        composite -blend $percent $first_frame $last_frame $out
    done
}
function get_first_frame() {
    echo "$WORKSPACE/$(list_frames | sort -n | head -n 1)"
}
function get_last_frame() {
    local last_i=$(list_frames | wc -l)
    if [[ $((last_i % frame_interval)) -eq 0 ]]
    then last_i=$((last_i - frame_interval))
    else last_i=$(((last_i / frame_interval) * frame_interval))
    fi
    set +x
    local f i=0
    for f in $(list_frames | sort -n); do
        if [[ $((i % frame_interval)) -eq 0 ]]; then
            f="$WORKSPACE/$f"
            if [[ $i -eq $last_i ]]; then
                echo "$f"
                break
            fi
        fi
        i=$((i + 1))
    done
    set_x
}
gen_counter=1
function gen_gif() {
    local width="$1"
    eval "$(convert_cmd $width)"
    local s="$(ls -sh "$output_gif"|tail -n 1|awk '{print $1}')"
    printf '#%d: %7s %4sB\n' $gen_counter $(get_geometry) $s;
    gen_counter=$((gen_counter + 1))
}
function list_blendeds() {
    ls -- "$WORKSPACE" | grep -P '^__blended-\d+\.png$'
}
function convert_cmd() {
    local width="$1"
    local delay=$((delay_factor * frame_interval))
    local arg="-delay $delay"
    local last_frame=$(get_last_frame)
    set +x
    local f i=0
    for f in $(list_frames | sort -n); do
        if [[ $((i % frame_interval)) -eq 0 ]]; then
            f="$WORKSPACE/$f"
            if [[ "$f" = "$last_frame" ]]
            then arg="$arg -delay $last_delay '$f'"
            else arg="$arg '$f'"
            fi
        fi
        i=$((i + 1))
    done
    set_x
    if [[ $blend_loop -gt 0 ]]; then
        arg="$arg -delay $delay"
        for f in $(list_blendeds | sort -n); do
            f="$WORKSPACE/$f"
            arg="$arg '$f'"
        done
    fi
    echo -n "convert $arg -loop 0 "
    echo -n "-geometry ${width}x "
    if $is_dither
    then echo -n "-dither FloydSteinberg "
    else echo -n "+dither "
    fi
    echo -n "-modulate 100,$saturation "
    if [[ $fuzz -gt 0 ]]
    then echo -n "-fuzz ${fuzz}% "
    fi
    echo -n "-layers OptimizeTransparency \"$output_gif\""
}
function hook_after_view() {
    [[ $# -gt 0 ]] || return
    if type after_view &> /dev/null
    then after_view "$@"
    else echo "Generate png files: $@"
    fi
}
function hook_after_gen() {
    [[ $# -eq 1 ]] || return
    if type after_gen &> /dev/null
    then after_gen "$1"
    else echo "Build gif: $1"
    fi
}
function load_rc() {
    if [[ ! -f "$RC_FILE" ]]
    then create_rc
    fi
    debug "load $RC_FILE"
    . "$RC_FILE"
}
function create_rc() {
    echo "Create default config: $RC_FILE"
    if ! [[ "$0" =~ tumblr-gif ]]; then
        echo '#!/bin/bash -eu' > "$RC_FILE"
        return 0
    fi
    start=$(grep -Pn '##[S]TART_SAMPLE_CONF' $0 | cut -d: -f1)
    end=$(grep -Pn '##[E]ND_SAMPLE_CONF' $0 | cut -d: -f1)
    head -n $((end - 1)) $0 \
        | tail -n $((end - start - 1)) \
        | sed -e 's/^ *://' > "$RC_FILE"
    return 0
: '
:##START_SAMPLE_CONF
:#!/bin/bash -eu
:# -*- coding:utf-8; mode:sh; -*-
:
:###########################################################
:## env
:
:# export PATH="${HOME}/local/bin:${PATH}"
:# export LD_LIBRARY_PATH="${HOME}/local/lib:${LD_LIBRARY_PATH-}"
:
:###########################################################
:## hooks on each tasks
:
:after_view() { # argument: generated png file pathes
:    echo "generate $# PNG files"
:    xdg-open "$(dirname "$1")"
:}
:
:after_gen() { # artument: a generated gif path
:    xdg-open "$1"
:}
:##END_SAMPLE_CONF
'
}
function cli_clean() {
  clean_files
  return 0;
}
function cli_gen() {
  DEFAULT_INIT_WIDTH=500
  DEFAULT_HALF_INIT_WIDTH=245
  saturation=100
  init_width=$DEFAULT_INIT_WIDTH
  fuzz=2
  frame_interval=2
  last_delay=
  delay_factor=3
  blend_loop=0
  is_echo_convert=false
  output_gif=
  is_half=false
  is_dither=true
  usage="Usage: $(basename "$0") [<option> [ ... ] ] <output_gif>
      -s,--saturation NUM     :
          set this smaller NUM if tumblr return \"Error uploading image\".
          default: $saturation, max: 100, min: 1
      -w,--init-width NUM     : default: $init_width
      -f,--fuzz NUM           :
          set this smaller NUM then a smaller gif was generated. default: $fuzz
      -i,--frame-interval NUM :
          set this larger NUM if tumblr return \"Error uploading image\".
          set this larger NUM then a smaller gif was generated.
          default: $frame_interval
      -l,--last-delay NUM     :
          set this larger NUM if you want a gif which has the last frame stop
          for NUM delay.
          default: ( delay-factor * frame-interval )
      --delay-factor NUM      :
          set this larger NUM if you want a gif at faster speed animation.
          default: $delay_factor
      -b,--blend-loop NUM     :
          blending between the first frame and the last frame with NUM frame.
          default: $blend_loop
      --echo-convert          : just output 'convert' cmmands. does not execute.
      --half                  :
          generate a gif which be the half size and
          the upper limit file size is 2MB.
      --no-dither             : without dither option.
      -h,--help
  "
  while [[ $# -gt 0 ]]; do
      case "$1" in
          -s|--saturation)
              is_int "$2" || abort "$1 argument must integer: $2"
              saturation="$2"
              shift
              ;;
          -w|--init-width)
              is_int "$2" || abort "$1 argument must integer: $2"
              init_width="$2"
              shift
              ;;
          -f|--fuzz)
              is_int "$2" || abort "$1 argument must integer: $2"
              fuzz="$2"
              shift
              ;;
          -i|--frame-interval)
              is_int "$2" || abort "$1 argument must integer: $2"
              frame_interval="$2"
              shift
              ;;
          -l|--last-delay)
              is_int "$2" || abort "$1 argument must integer: $2"
              last_delay=$2
              shift
              ;;
          -b|--delay-factor)
              is_int "$2" || abort "$1 argument must integer: $2"
              delay_factor=$2
              shift
              ;;
          --blend-loop)
              is_int "$2" || abort "$1 argument must integer: $2"
              blend_loop=$2
              shift
              ;;
          --echo-convert)
              is_echo_convert=true
              ;;
          --half)
              is_half=true
              if [[ $init_width -eq $DEFAULT_INIT_WIDTH ]]
              then init_width=$DEFAULT_HALF_INIT_WIDTH
              fi
              ;;
          --no-dither)
              is_dither=false
              ;;
          -h|--help) abort "$usage" ;;
          -*) abort "unknown option: $1" ;;
          *)
              [[ -z "$output_gif" ]] || abort "invalid argument: $1"
              output_gif="$1"
              ;;
      esac
      shift
  done
  if [[ -z "$last_delay" ]]
  then last_delay=$((delay_factor * frame_interval))
  fi
  if [[ -z "$output_gif" ]]
  then abort "$usage"
  fi
  (
      for v in saturation init_width fuzz frame_interval last_delay delay_factor \
          blend_loop is_echo_convert is_half is_dither output_gif
      do eval echo "$v : \$$v"
      done
      echo -------------------
  ) | column -t
  do_convert
  hook_after_gen "$output_gif"
  return 0;
}
function cli_view() {
  usage="Usage: $(basename "$0") view <video_file> <offset_time> <duration_sec>
    <offset_time>: HH:MM:SS or HH:MM:SS.ss"
  if [[ $# -ne 3 ]]; then
      abort "$usage"
  fi
  clean_files
  video_file="$1"
  offset_time="$2"
  duration_sec="$3"
  mkdir -pv "$WORKSPACE"
  avconv -r 30 -i "$video_file" -f image2 \
      -filter:v yadif -ss "$offset_time" -s '500x280' \
      -t "$duration_sec" "$WORKSPACE/%04d.png"
  pngs=()
  set +u
  for p in $WORKSPACE/*.png; do
      if [[ -f "$p" ]]
      then pngs=("${pngs[@]}" "$p")
      fi
  done
  if [[ ${#pngs} -gt 0 ]]
  then hook_after_view "${pngs[@]}"
  else abort "ERROR: no png on '$WORKSPACE'"
  fi
  set -u
  return 0;
}
function __run() {
  local pid=""
  local status=255
  set_x
  load_rc
  avconv -version &>/dev/null || avconv
  convert -version &>/dev/null || convert
  local cmd="${1-}"
  shift || true
  case "$cmd" in
    "") __run "help"; return $?;;
    "clean") cli_clean "$@" & local pid="$!";;
    "gen") cli_gen "$@" & local pid="$!";;
    "view") cli_view "$@" & local pid="$!";;
    "help")
      echo "Usage: tumblr-gif <task> [...]" 1>&2
      cat 1>&2 <<HELP

    clean    :  delete all png
    gen      :  generate gif which meets tumblr gif specification
    help     :  display this help message
    version  :  display version
    view     :  generating and viewing png

HELP
      status=0
      ;;
    "version")
      echo "tumblr-gif 1.1.0 (bash $BASH_VERSION)"
      status=0
      ;;
    *) echo "Unknown Command: $cmd" 1>&2;;
  esac
  if [ ! -z "$pid" ]; then
      wait "$pid"
      local status=$?
  fi
  return $status
}
__run "$@"
export __STATUS="$?"
exit $__STATUS
